# Урок 4 – Движения игрока.
В этом уроке мы научимся управлять игроком нажатием кнопок на клавиатуре.

Все управление будет прописано в двух классах:
1. В классе `Controller` мы будем перехватывать нажатие кнопки клавиатуры и передавать его в класс `Player`.
2. В классе `Player` мы будем двигать нашего игрока в зависимости от нажатой кнопки.

Выводом игрока на экран по прежнему будет заниматься класс `Gui`.

Первым делом перенесем обработчик событий из класса `Gui` в класс `Controller`. Там ему будет самое место.

Для этого из функции `Gui.update` переносим блок кода в тело функции `Controller.run` и ставим его в тело цикла `while`. Так мы каждый раз будем проверять событие на каждой итерации цикла.

            while 1:
                for e in pygame.event.get():
                    if e.type == pygame.QUIT:
                        exit()
                ...

Далее подготовим класс `Player`. Введем дополнительные свойства класса:
В функции __init__(self) прописываем параметр скорости и параметры стороны движения:

        # Скорость движения игрока
        self.speed = 3
        # Движение по горизонтальной оси x
        self.dx = 0
        # Движение по вертикальной оси y
        self.dy = 0

Теперь в классе контроллера дорабатываем обработчик нажатий клавиш:

В функции run, перед началом цикла прописываем начальные значения движения, равные `False`. Т.е. в начале игры, игрок стоит и никуда не двигается:

        def run(self):
            # Задаем начальные значения сторон движения равные False
            move_left = move_right = move_up = move_down = False
            ...

Далее в цикле мы проверяем какая кнопка нажата, и выставляем нужное значение в `True`:

        while 1:
            for e in pygame.event.get():
                # Общая логика такая:
                # Если клавиша нажата, и она является одной из списка:
                # То необходимая сторона движения меняется на True

                if e.type == pygame.KEYDOWN and e.key in [pygame.K_LEFT,
                                                          pygame.K_a]:
                    move_left = True
                if e.type == pygame.KEYDOWN and e.key in [pygame.K_RIGHT,
                                                          pygame.K_d]:
                    move_right = True
                if e.type == pygame.KEYDOWN and e.key in [pygame.K_UP,
                                                          pygame.K_w]:
                    move_up = True
                if e.type == pygame.KEYDOWN and e.key in [pygame.K_DOWN,
                                                          pygame.K_s]:
                    move_down = True
            ...

И далее мы не забываем отменять движение игрока в случае отжатия клавишы:

                # Логика так же:
                # Если клавиша отжата, и она является одной из списка:
                # То необходимая сторона движения меняется на False
                if e.type == pygame.KEYUP and e.key in [pygame.K_LEFT,
                                                        pygame.K_a]:
                    move_left = False
                if e.type == pygame.KEYUP and e.key in [pygame.K_RIGHT,
                                                        pygame.K_d]:
                    move_right = False
                if e.type == pygame.KEYUP and e.key in [pygame.K_UP,
                                                        pygame.K_w]:
                    move_up = False
                if e.type == pygame.KEYUP and e.key in [pygame.K_DOWN,
                                                        pygame.K_s]:
                    move_down = False

Теперь нам нужно передать данные о нажатии клавиш нашему игроку. В классе `Player` создадим метод `move` на вход которой будем принимать все четыре стороны движения.
Далее в контроллере создаем передачу значений в функцию `move`.

        def run(self):
            ...
                в теле цикла проводим передвижение персонажа
                self.player.move(move_left=move_left, move_right=move_right, move_up=move_up, move_down=move_down)
                # а после выводим на экран
                self.gui.update()

Теперь пишем основной обработчик предвижения в классе `Player`.

    def move(self, move_left, move_right, move_up, move_down):
        
        # Обрабатываем горизонтальное движение по оси x
        # Общая логика такая:
        # Если игрок получает сторону движения равной True,
        # то мы меняем его значение dx или dy (изменения координаты) равной значению скорости
        # значение утсанавливается положительное, если движемся по оси в сторону увеличения координат
        # значение отрицательное, если движемся, если движемся по оси в сторону уменьшения координат
        
        # если мы получаем False для обеих сторон движения по оси, то обнуляем значение изменения координат
        if move_left:
            self.dx = self.speed
        if move_right:
            self.dx = -self.speed
        if not (move_left or move_right):
            self.dx = 0
        if move_up:
            self.dy = self.speed
        if move_down:
            self.dy = -self.speed
        if not (move_up or move_down):
            self.dy = 0

Далее мы координаты игрока изменяем на величину dx и dy.

        self.x += self.dx
        self.y += self.dy

---

# Урок 4.0 – Замедление.

Если запустить main.py, то движения игрока будут быстрыми, это говорит о высокой скорости работы цикла `Controller.run.while`.
Для искусственного занижения скорости работы, создадим ограничитель, который будет управлять задержкой работы цикла в диапазоне 60 циклов в секунду.

В функции `__init__(self)` класса `Controller` создадим переменную отвечающую за отсчет времени внутри программы:

    def __init__(self):
        self.clock = pygame.time.Clock()
    ...

А в цикле функции run(self) введем задержку, обеспечивающую максимальное колчество обновлений цикла равным 60:

        while 1:
            self.clock.tick(60)
            ...

Если снова запустить игру, то движения будут медленнее.

---

# Урок 4.1 – Прыжки.
Так как движения игрока происходят по плоскости с видом свержу, то для обработки прыжков будем использовать псевдо ось `z`.

Для обработки прыжков, мы проведем небольшие изменения класса `Controller`, и чуть больше пропишем в классе `Player`.

Назначим обработчики для прыжков в цикле `while` функции `run()`. Редактируем `class_controller.py`:

            move_left = move_right = move_up = move_down = move_jump = False

            ...
            
                # Если нажата клавиша пробел, то выполняется прыжок
                if e.type == pygame.KEYDOWN and e.key in [pygame.K_SPACE]:
                    move_jump = True
                ...
                # Если отжата клавиша пробел, то выполняется прыжок
                if e.type == pygame.KEYUP and e.key in [pygame.K_SPACE]:
                    move_jump = False
                ...
            # Передаем состояние прыжка в класс игрока
            self.player.move(move_left=move_left, move_right=move_right, move_up=move_up, move_down=move_down, move_jump=move_jump)
            ...

Теперь нам предстоит провести обработку прыжка классом `Player`.

Начнем с того, что нам необходимо ввести новые переменные для контроля прыжков.

В функции `__init__()` объявляем новые переменные и присваиваем им соответствующие значения:

    def __init__(self):
        ...
        # Сила прыжка
        self.jump_power = 5
        # состояние нахождения на земле или в воздухе. Чтобы нельзя было сделать двойной прыжок (прыжок во время прыжка)
        self.onGround = False
        # нахождение игрока в координатах оси z
        self.z = 0
        # Изменение по оси z
        self.dz = 0
        # сила гравитации (при падении координата игрока по оси z меняется с заданной скоростью)
        self.g = 0.35
        ...

Дополнительно отделим физическое нахождение персонажа в координатах `x`, `y` и `z` то отображаемого тайла.
Это делается из-за того, что координата `z` рисуется в той же координате, что и `y`.

Поэтому в функции `__init__` класса `Player` допишем в конце строку:

        # Создаем прямоугольник, который мы будем видеть
        self.sprite.rect = pygame.Rect(self.x, self.y, self.width, self.height)

Далее в функции `move` прописываем обработку прыжков:

    def move(self, move_left, move_right, move_up, move_down, move_jump):
        ...

        # Первым делом проверяем в прыжке наш игрок или нет:
        if self.onGround and move_jump:
            # Ели игрок стоит на земле и выполняет прыжок, то изменение dz будет отрицательное и равным силе прыжка
            self.dz = -self.jump_power
        if not self.onGround:
            # Если игрок в воздухе, то его значение dz меняется на величину гравитации
            self.dz += self.g
        ...

        self.x += self.dx
        # Меняем отображение игрока по оси x
        self.sprite.rect.x = self.x
        
        self.y += self.dy
        # Так как у нас проекция с видом сверху, то изменение прыжка будет отражаться в координатах оси y
        self.sprite.rect.y = self.y + self.z
        
        # И не забываем обновить координату z
        self.z += self.dz
        # Проверяем, если она будет больше 0 (уровень пола),
        # то ставим флажок, что игрок стоит на полу, иначе оставляем его в состоянии прыжка
        if self.z >= 0:
            self.z = 0
            self.dz = 0
            self.onGround = True
        else:
            self.onGround = False

И последнее: В классе `Gui` делаем отображение по координатам прямоугольного спрайта, а не по координатам `x` и `y`.

Редактируем `class_gui`:

        # отображаем игрока по координатам спрайта
        self.screen.blit(self.controller.player.sprite.image, (self.controller.player.sprite.rect.x, self.controller.player.sprite.rect.y))

---

### Работа над ошибками

Если вы запустите программу, то у вас будут неправильно назначены стороны движения на кнопки.

При нажатии вниз - будет идти вверх, при нажатии влево - будет идти вправо и наоборот.

Для исправления такой ошибки, необходимо поменять знак при присвоении значения скорости на изменение по осям `dx` и `dy`.

Из-за того, что начало координат (0, 0) у нас находится в левом верхнем углу, то при движении влево, у нас `dx` должен быть меньше 0, т.к. мы движемся в сторону уменьшения координаты `x`.
При движении вправо, мы движемся в сторону увеличения координаты по оси `x`, следовательно значение `dx` должно быть больше 0.

При движении вверх, мы движемся по оси `y` в сторону уменьшения координаты, а при движении вниз - в сторону увеличения координаты по оси `y`.

Блок должен быть записан следующим образом:

        if move_left:
            self.dx = -self.speed
        if move_right:
            self.dx = self.speed
        ...
        if move_up:
            self.dy = -self.speed
        if move_down:
            self.dy = self.speed