# Урок 4 – Движения игрока.
В этом уроке мы научимся управлять игроком нажатием кнопок на клавиатуре.

Все управление будет прописано в двух классах:
1. В классе `Controller` мы будем перехватывать нажатие кнопки клавиатуры и передавать его в класс `Player`.
2. В классе `Player` мы будем двигать нашего игрока в зависимости от нажатой кнопки.

Выводом игрока на экран по прежнему будет заниматься класс `Gui`.

Первым делом перенесем обработчик событий из класса `Gui` в класс `Controller`. Там ему будет самое место.

Для этого из функции `Gui.update` переносим блок кода в тело функции `Controller.run` и ставим его в тело цикла `while`. Так мы каждый раз будем проверять событие на каждой итерации цикла.

            while 1:
                for e in pygame.event.get():
                    if e.type == pygame.QUIT:
                        exit()
                ...

Далее подготовим класс `Player`. Введем дополнительные свойства класса:
В функции __init__(self) прописываем параметр скорости и параметры стороны движения:

        # Скорость движения игрока
        self.speed = 3
        # Движение по горизонтальной оси x
        self.dx = 0
        # Движение по вертикальной оси y
        self.dy = 0

Теперь в классе контроллера дорабатываем обработчик нажатий клавиш:

В функции run, перед началом цикла прописываем начальные значения движения, равные `False`. Т.е. в начале игры, игрок стоит и никуда не двигается:

        def run(self):
            # Задаем начальные значения сторон движения равные False
            move_left = move_right = move_up = move_down = False
            ...

Далее в цикле мы проверяем какая кнопка нажата, и выставляем нужное значение в `True`:

        while 1:
            for e in pygame.event.get():
                # Общая логика такая:
                # Если клавиша нажата, и она является одной из списка:
                # То необходимая сторона движения меняется на True

                if e.type == pygame.KEYDOWN and e.key in [pygame.K_LEFT,
                                                          pygame.K_a]:
                    move_left = True
                if e.type == pygame.KEYDOWN and e.key in [pygame.K_RIGHT,
                                                          pygame.K_d]:
                    move_right = True
                if e.type == pygame.KEYDOWN and e.key in [pygame.K_UP,
                                                          pygame.K_w]:
                    move_up = True
                if e.type == pygame.KEYDOWN and e.key in [pygame.K_DOWN,
                                                          pygame.K_s]:
                    move_down = True
            ...

И далее мы не забываем отменять движение игрока в случае отжатия клавишы:

                # Логика так же:
                # Если клавиша отжата, и она является одной из списка:
                # То необходимая сторона движения меняется на False
                if e.type == pygame.KEYUP and e.key in [pygame.K_LEFT,
                                                        pygame.K_a]:
                    move_left = False
                if e.type == pygame.KEYUP and e.key in [pygame.K_RIGHT,
                                                        pygame.K_d]:
                    move_right = False
                if e.type == pygame.KEYUP and e.key in [pygame.K_UP,
                                                        pygame.K_w]:
                    move_up = False
                if e.type == pygame.KEYUP and e.key in [pygame.K_DOWN,
                                                        pygame.K_s]:
                    move_down = False

Теперь нам нужно передать данные о нажатии клавиш нашему игроку. В классе `Player` создадим метод `move` на вход которой будем принимать все четыре стороны движения.
Далее в контроллере создаем передачу значений в функцию `move`.

        def run(self):
            ...
                в теле цикла проводим передвижение персонажа
                self.player.move(move_left=move_left, move_right=move_right, move_up=move_up, move_down=move_down)
                # а после выводим на экран
                self.gui.update()

Теперь пишем основной обработчик предвижения в классе `Player`.

    def move(self, move_left, move_right, move_up, move_down):
        
        # Обрабатываем горизонтальное движение по оси x
        # Общая логика такая:
        # Если игрок получает сторону движения равной True,
        # то мы меняем его значение dx или dy (изменения координаты) равной значению скорости
        # значение утсанавливается положительное, если движемся по оси в сторону увеличения координат
        # значение отрицательное, если движемся, если движемся по оси в сторону уменьшения координат
        
        # если мы получаем False для обеих сторон движения по оси, то обнуляем значение изменения координат
        if move_left:
            self.dx = self.speed
        if move_right:
            self.dx = -self.speed
        if not (move_left or move_right):
            self.dx = 0
        if move_up:
            self.dy = self.speed
        if move_down:
            self.dy = -self.speed
        if not (move_up or move_down):
            self.dy = 0

Далее мы координаты игрока изменяем на величину dx и dy.

        self.x += self.dx
        self.y += self.dy

Если запустить main.py, то движения игрока будут быстрыми, это говорит о высокой скорости работы цикла `Controller.run.while`.
Для искусственного занижения скорости работы, создадим ограничитель, который будет управлять задержкой работы цикла в диапазоне 60 циклов в секунду.

В функции `__init__(self)` класса `Controller` создадим переменную отвечающую за отсчет времени внутри программы:

    def __init__(self):
        self.clock = pygame.time.Clock()
    ...

А в цикле функции run(self) введем задержку, обеспечивающую максимальное колчество обновлений цикла равным 60:

        while 1:
            self.clock.tick(60)
            ...

Если снова запустить игру, то движения будут медленнее.
